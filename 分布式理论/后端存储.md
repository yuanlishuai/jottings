# 后端存储

## 分布式事务

> 并没有一种分布式的服务或者组件，能帮助我们很简单的就解决分布式系统下的数据一致性问题。我们在使用分布式事务的时候，更多情况下使用分布式的的理论来指导开发，自行解决数据一致性的问题，也就是说，要解决分布式一致性问题，你必须掌握几种分布式事务的原理     

### 2PC (二阶段提交)

> 2PC 引入了一个`事务协调者`   等每个事务参与者都准备完成后，事务协调者会发送**提交**的命令，然后每个系统提交自己的数据库事务，然后在返回给事务提交者**提交成功**响应，协调者收到说有的成功响应后，给客户端响应成功整个分布式事务就结束了，
>
> 如果准备阶段失败，会发出**回退** 指令， 各个数据库进行回滚，响应客户端失败，结束。
>
> 如果准备阶段成功，进入提交阶段，这时候整个分数是事务就**只能成功，不能失败** ，若网络问题，会不断重试知道提交成功为止

##### 2PC 优缺点

> 2PC 是一种**强一致性设计**，他可以保证原子性和隔离性，只要2PC完成，那个它的数据就是一致的，也就是说要呢都成功要么都失败。因此2PC适用于一些对数据一致性要求比较高的场景 
>
> 2PC也有明显的缺点，**整个事务的执行过程需要阻塞服务端的线程和数据库的会话** ，所以2PC在一下并发度场景下性能不是很高，而且协调者是一个单点，一单协调过程中宕机就会导致事务会话一直卡在等待提交阶段，知道事务超时自动回滚 ，
>
> **所有只有在需要强一致、并发量不大的请情况下，才考虑使用2PC**

### 本地消息表

> 本地消息表非常适合解决这种**分布式最终一致性的问题** 。 它的实现思路是正常的使用数据库的事务去操作数据，在执行这个事务的同时会在本地记录一条消息，这个消息的内容就是该事务设计需要操作的其他数据库的数据，因为这个操作是本地的所以没有分布式事务的问题，也就是说这个就是一个单机版的本地事务。 然后我们用一个**异步服务去读取刚才的本地消息** 去然后执行本地消息，变更本地消息状态，如果操作失败，可以重试，最终达到数据一致
>
> 本地消息可以存数据库里也可以存本地磁盘里
>
> 消息队列RockerMQ 提供的一种事务性消息，其实就是本地消息表的一种实现，使用事务消息可以达到和本地消息表一样的最终一致性，相比我么你自己实现本地消息表来说，更简单便捷

###### 本地消息表优缺点

> 实现简单，在单机事务上稍加改造就可以实现分布式事务，另外本地消息表的性能非常好，和单机的事务性能几乎没有差别，在这个基础上还提供了大部分情况下的都能接受的**数据最终一致性**的保证，所以本地消息表是更加实用的分布式事务的实现方法
>
> 实现本地消息表有一个前提条件，就是**异步执行的那部分操作，不能有依赖资源**，比如说下单的时候，除了要清空购物车以外，还要锁定库存



>2PC 它的优点是强一致性，到时性能和可用性上存在以下缺陷。本地消息表使用性更广泛，虽然在数据一致性上有所牺牲，只能满足最终一致性，但是有更好的性能，实现简单，系统稳定性也很好，是一种非常实用的分布式事务解决方案
>
>无论哪种分布式事务方法，其实都是把一个分布式事务，拆分厂多个本地事务，**本地事务可以用数据库事务来解决，那分布式事务就专注于解决如何让这些本地事务保持一致性的问题。** 



------------



##  ElasticSearch

| ElasticScratch | RMBMS  |
| :------------: | :----: |
|     INDEX      |   表   |
|    DOCUMENT    |   行   |
|     FIELD      |   列   |
|    MAPPING     | 表结构 |

>   在ES里面，数据的逻辑结构类似于MongoDB，每条数据称为**DOCUMENT**，简称DOC，DOC是一个JSON对象，DOC中每个JSON字段，在ES中称为FIELD，把一组具有相同字段的DOC存放在一起，存放它的逻辑容器叫做**INDEX**，这些DOC的JSON结构称为**MAPPING**。  这里的index 实际上类似于MySQL中的表概念，而不是我们通常理解的用于查找数据的索引。

###  Analysis 分词

  中文分词器： **IK Analysis for Elasticsearch**



------





## MySQL HA

> 能够影响数据库安全的事件，都是极小概率的事件，比如说数据库宕机、磁盘损坏甚至机房着火。
>
> 一般来说存储系统导致的比较严重的损失主要有两种情况：
>
> 一是数据丢失造成直接的财产损失，比如大量坏账；
>
> 二是由于存储系统损坏，造成整个业务系统停止服务而带来的损失  

### 如何更安全的做数据备份和恢复

####   备份方式

1. 全量备份

   > 最简单的方式就是全量备份。  MySQL 可以使用 mysqldump 命令来执行全量备份  
   >
   > 备份文件会包含数据库中的所有数据。占用磁盘空间非常大；其次，每次备份操作都要拷贝大量的数据，备份过程中会占用数据库服务器大量的CPU、磁盘IO资源，并且为了保证数据一致性，还可能会锁表。这些将导致数据库本身性能严重下降，

   

2. 增量备份

> 既然全量备份代价太高，不能频繁执行。 SO ->**增量备份** 。增量备份每一次至备份相当于上一次备份变化的那部分数据，所以增量备份速度更快。
>
> MySQL 自带的binlog ，就是一种实时的增量备份。binlog里面记录的就是MySQL数据变更的操作日志，开启binlog后，我们对mysql 中数据每次更新操作都会被记录到binlog中。
>
> binlog是可以回放的，回放binlog，就相当于把之前对数据库所有数据更新操作按照顺序执行了一遍，回放完数据就自然恢复了。   





#### 执行备份和恢复的时候注意点：

> 第一，也是最重要的，**不要把所有的鸡蛋都放到同一个篮子里**，无论是全量备份还是增量备份（binlog），都不要和数据库放到同一个服务器上。最好能做到不同机房，甚至不同城市，里的越远越好
>
> 第二，在回放binlog 的时候，指定的其实时间可以比全备的时间稍微提前一点，确保全量备份之后所有操作都在恢复的binlog范围内，这样可以保证恢复的数据的完整性。
>
> **因为回放binlog的操作是具备幂等性的。为了确保回放幂等，需要设置binlog的格式为 `ROW` 格式**



### 配置MySQL HA 实现高可用

> 数据量很大的时候，MySQL恢复数据是很耗时的，可能几个小时。 这期间是不可用的。---> MySQL 提供了主从复制功能

####    主从复制时序

1. 在主库磁盘写入Binlog；

2. 主库更新存储引擎中的数据；

3. 给客户端返回成功响应；

4. 主库把Biglog复制到从库；

   从库回放Binlog，更新存储引擎中的数据

   > 会存在从库比主库的数据旧一点，这中情况叫做`主从延迟` 。**正常情况下主从延迟基本上都是毫秒级别的**
   >
   > 主机先繁忙--性能下降--最终宕机。这中情况下主从延迟可能很大，，如果直接切换到从库上可能会丢数据，即使到时时候找到了主库的binlog  也无法执行，因为和从库的数据是冲突的。因此MySQL又提供了一种 叫**同步复制**。 
   >
   > MySQL开启同步复制时，主库会等待数据成功复制大从库之后再给客户端返回。
   >
   > 同步复制，再一主一从的情况下，如果从宕机了主库会一直等待从库，主库也卡死了。 所以再加一个从库，将主库配置成：**成功复制到任意一个从库就返回，只要有一个从库还活着，就不会影响主库写入数据**

   

#### 主从方案对比

|             方案             | 高可用 | 可能丢失数据 | 性能 |
| :--------------------------: | :----: | :----------: | :--: |
| 一主一从，异步复制，手动切换 |   否   |     可控     |  好  |
| 一主一从，异步复制，自动切换 |   是   |      是      |  好  |
| 一主二从，同步复制，自动切换 |   是   |      否      |  差  |



  

## 定量认识 MySQL

> 慢SQL对数据库的影响，是一个量变到质变的过程，对‘量’的把我就很重要，

一台MySQL 数据库大致处理能力极限是，**每秒一万条左右的简单SQL**，这里的简单SQL指的是类似于主键查询这中不需要遍历很多条记录的SQL  

 一般一台MySQL服务器，平均每秒执行SQL数量在几百条左右，就已经非常繁忙了，即使看起来CPU利用率和磁盘繁忙程度没有那么高。遍历行数千万左右，是MySQL查询的一个瓶颈，

**使用索引避免全表扫描**   

> 添加合适的索引

**分析SQL执行计划**









  

