# 后端存储

## 分布式事务

> 并没有一种分布式的服务或者组件，能帮助我们很简单的就解决分布式系统下的数据一致性问题。我们在使用分布式事务的时候，更多情况下使用分布式的的理论来指导开发，自行解决数据一致性的问题，也就是说，要解决分布式一致性问题，你必须掌握几种分布式事务的原理     

### 2PC (二阶段提交)

> 2PC 引入了一个`事务协调者`   等每个事务参与者都准备完成后，事务协调者会发送**提交**的命令，然后每个系统提交自己的数据库事务，然后在返回给事务提交者**提交成功**响应，协调者收到说有的成功响应后，给客户端响应成功整个分布式事务就结束了，
>
> 如果准备阶段失败，会发出**回退** 指令， 各个数据库进行回滚，响应客户端失败，结束。
>
> 如果准备阶段成功，进入提交阶段，这时候整个分数是事务就**只能成功，不能失败** ，若网络问题，会不断重试知道提交成功为止

##### 2PC 优缺点

> 2PC 是一种**强一致性设计**，他可以保证原子性和隔离性，只要2PC完成，那个它的数据就是一致的，也就是说要呢都成功要么都失败。因此2PC适用于一些对数据一致性要求比较高的场景 
>
> 2PC也有明显的缺点，**整个事务的执行过程需要阻塞服务端的线程和数据库的会话** ，所以2PC在一下并发度场景下性能不是很高，而且协调者是一个单点，一单协调过程中宕机就会导致事务会话一直卡在等待提交阶段，知道事务超时自动回滚 ，
>
> **所有只有在需要强一致、并发量不大的请情况下，才考虑使用2PC**

### 本地消息表

> 本地消息表非常适合解决这种**分布式最终一致性的问题** 。 它的实现思路是正常的使用数据库的事务去操作数据，在执行这个事务的同时会在本地记录一条消息，这个消息的内容就是该事务设计需要操作的其他数据库的数据，因为这个操作是本地的所以没有分布式事务的问题，也就是说这个就是一个单机版的本地事务。 然后我们用一个**异步服务去读取刚才的本地消息** 去然后执行本地消息，变更本地消息状态，如果操作失败，可以重试，最终达到数据一致
>
> 本地消息可以存数据库里也可以存本地磁盘里
>
> 消息队列RockerMQ 提供的一种事务性消息，其实就是本地消息表的一种实现，使用事务消息可以达到和本地消息表一样的最终一致性，相比我么你自己实现本地消息表来说，更简单便捷

###### 本地消息表优缺点

> 实现简单，在单机事务上稍加改造就可以实现分布式事务，另外本地消息表的性能非常好，和单机的事务性能几乎没有差别，在这个基础上还提供了大部分情况下的都能接受的**数据最终一致性**的保证，所以本地消息表是更加实用的分布式事务的实现方法
>
> 实现本地消息表有一个前提条件，就是**异步执行的那部分操作，不能有依赖资源**，比如说下单的时候，除了要清空购物车以外，还要锁定库存



>2PC 它的优点是强一致性，到时性能和可用性上存在以下缺陷。本地消息表使用性更广泛，虽然在数据一致性上有所牺牲，只能满足最终一致性，但是有更好的性能，实现简单，系统稳定性也很好，是一种非常实用的分布式事务解决方案
>
>无论哪种分布式事务方法，其实都是把一个分布式事务，拆分厂多个本地事务，**本地事务可以用数据库事务来解决，那分布式事务就专注于解决如何让这些本地事务保持一致性的问题。** 



------------



##  ElasticSearch

| ElasticScratch | RMBMS  |
| :------------: | :----: |
|     INDEX      |   表   |
|    DOCUMENT    |   行   |
|     FIELD      |   列   |
|    MAPPING     | 表结构 |

>   在ES里面，数据的逻辑结构类似于MongoDB，每条数据称为**DOCUMENT**，简称DOC，DOC是一个JSON对象，DOC中每个JSON字段，在ES中称为FIELD，把一组具有相同字段的DOC存放在一起，存放它的逻辑容器叫做**INDEX**，这些DOC的JSON结构称为**MAPPING**。  这里的index 实际上类似于MySQL中的表概念，而不是我们通常理解的用于查找数据的索引。

###  Analysis 分词

  中文分词器： **IK Analysis for Elasticsearch**



------





## MySQL HA

> 能够影响数据库安全的事件，都是极小概率的事件，比如说数据库宕机、磁盘损坏甚至机房着火。
>
> 一般来说存储系统导致的比较严重的损失主要有两种情况：
>
> 一是数据丢失造成直接的财产损失，比如大量坏账；
>
> 二是由于存储系统损坏，造成整个业务系统停止服务而带来的损失  

### 如何更安全的做数据备份和恢复

####   备份方式

1. 全量备份

   > 最简单的方式就是全量备份。  MySQL 可以使用 mysqldump 命令来执行全量备份  
   >
   > 备份文件会包含数据库中的所有数据。占用磁盘空间非常大；其次，每次备份操作都要拷贝大量的数据，备份过程中会占用数据库服务器大量的CPU、磁盘IO资源，并且为了保证数据一致性，还可能会锁表。这些将导致数据库本身性能严重下降，

   

2. 增量备份

> 既然全量备份代价太高，不能频繁执行。 SO ->**增量备份** 。增量备份每一次至备份相当于上一次备份变化的那部分数据，所以增量备份速度更快。
>
> MySQL 自带的binlog ，就是一种实时的增量备份。binlog里面记录的就是MySQL数据变更的操作日志，开启binlog后，我们对mysql 中数据每次更新操作都会被记录到binlog中。
>
> binlog是可以回放的，回放binlog，就相当于把之前对数据库所有数据更新操作按照顺序执行了一遍，回放完数据就自然恢复了。   





#### 执行备份和恢复的时候注意点：

> 第一，也是最重要的，**不要把所有的鸡蛋都放到同一个篮子里**，无论是全量备份还是增量备份（binlog），都不要和数据库放到同一个服务器上。最好能做到不同机房，甚至不同城市，里的越远越好
>
> 第二，在回放binlog 的时候，指定的其实时间可以比全备的时间稍微提前一点，确保全量备份之后所有操作都在恢复的binlog范围内，这样可以保证恢复的数据的完整性。
>
> **因为回放binlog的操作是具备幂等性的。为了确保回放幂等，需要设置binlog的格式为 `ROW` 格式**



### 配置MySQL HA 实现高可用

> 数据量很大的时候，MySQL恢复数据是很耗时的，可能几个小时。 这期间是不可用的。---> MySQL 提供了主从复制功能

####    主从复制时序

1. 在主库磁盘写入Binlog；

2. 主库更新存储引擎中的数据；

3. 给客户端返回成功响应；

4. 主库把Biglog复制到从库；

   从库回放Binlog，更新存储引擎中的数据

   > 会存在从库比主库的数据旧一点，这中情况叫做`主从延迟` 。**正常情况下主从延迟基本上都是毫秒级别的**
   >
   > 主机先繁忙--性能下降--最终宕机。这中情况下主从延迟可能很大，，如果直接切换到从库上可能会丢数据，即使到时时候找到了主库的binlog  也无法执行，因为和从库的数据是冲突的。因此MySQL又提供了一种 叫**同步复制**。 
   >
   > MySQL开启同步复制时，主库会等待数据成功复制大从库之后再给客户端返回。
   >
   > 同步复制，再一主一从的情况下，如果从宕机了主库会一直等待从库，主库也卡死了。 所以再加一个从库，将主库配置成：**成功复制到任意一个从库就返回，只要有一个从库还活着，就不会影响主库写入数据**

   

#### 主从方案对比

|             方案             | 高可用 | 可能丢失数据 | 性能 |
| :--------------------------: | :----: | :----------: | :--: |
| 一主一从，异步复制，手动切换 |   否   |     可控     |  好  |
| 一主一从，异步复制，自动切换 |   是   |      是      |  好  |
| 一主二从，同步复制，自动切换 |   是   |      否      |  差  |



  

## 定量认识 MySQL

> 慢SQL对数据库的影响，是一个量变到质变的过程，对‘量’的把我就很重要，

一台MySQL 数据库大致处理能力极限是，**每秒一万条左右的简单SQL**，这里的简单SQL指的是类似于主键查询这中不需要遍历很多条记录的SQL  

 一般一台MySQL服务器，平均每秒执行SQL数量在几百条左右，就已经非常繁忙了，即使看起来CPU利用率和磁盘繁忙程度没有那么高。遍历行数千万左右，是MySQL查询的一个瓶颈，

**使用索引避免全表扫描**   

> 添加合适的索引

**分析SQL执行计划**

### 读写分离是提升MySQL的首选方案
 > 一个分布式的存储系统，想要做分布式的写非常困难的，因为很难解决数据一致性的问题。而对于分布式的读则非常简单。    
 
 简单来说实时MySQL的读写分离方案只需要两步：  
  第一步：部署一主多从多个MySQL实例，并让他们之间保持数据的实时同步；  
  第二步: 分离应用程序对数据库的读写请求，分别发送给主库和从库。  
  
  **分离应用程序的读写请求方法**
1.   纯手工方式：修改应用程序的DAO层代码，定义读写两个数据源，指定每一个数据库请求的数据源。  
2.   组件方式： 使用mycat、Sharding-JDBC 这种第三方组件来实现，集成在应用程序中，代理读写分离的请求，自动把请求路由到数据库实例上。  
3.   代理方式：在应用程序和数据库实例之间部署一组数据库代理实例，比如说Atlas 或者MaxScale。对于应用程序来说，数据库代理吧自己伪装成一个单节点的mysql实例，应用程序的素有数据库请求被发送个代理，代理分离读写请求，然后转发给对应的数据库实例。  

> 一般不推荐第三种代理方式，因为代理增加了系统运行时数据库请求的调用链路，有一定的性能损失，并且代理服务本身也可能出现故障和性能瓶颈等问题。**但是代理方式有一个好处是：对应用程序完全透明，所以只有在不方便修改应用程序代码这一情况下，才需要采用代理模式**  

>> 对于主从延迟带来的数据不一致问题，没有什么简单方便而且通用的技术方案可以解决，同常是重新设计业务逻辑，尽量规避更新数据后立即去从库查询刚刚更新的数据。  

随着系统用户的增长，当单个MySQL实例扛不住大量并发的时候，读写分离是首选的数据库扩容方案，读写分离不需要对数据做太大改动，就可以让系统支撑的并发提成几倍几十倍。 
  
## MySQL 主从同步

  同步复制这种方式在实际项目中，基本上没法用。一是性能很差，因为要复制到所有节点才返回响应，二是可用性很差，主库和所有从库任何一个数据库出现问题，都会影响业务。
  
  为解决这个问题 MySQL从5.7 开始，增加了一种半同步复制（SemisunchronousReplication）的方式。异步复制是事务线程完全不等待复制响应，同步复制是，事务线程要等待所有复制响应，版同步复制介于二者之间，事务线程不用不用等着所有的复制成功响应，只要一部分复制响应回来折后，就可以给客户端返回了。
  
  #### 复制状态机 ： 所有的分布式存储都是这么复制数据的
  **快照 + 操作日志** 这种方式并不是MySQL特有的  
  复制数据的时候，只有基于一个快照，按照顺序执行快照之后的所有操作日志，就可以得到一个完全一样的状态，从节点持续的从主节点上复制操作日志并执行，就可以让从节点上的状态数据和直接点操持同步。  
  
 ----
 
 ## 数据量越来越多、数据库越来越慢怎么办？
无论什么样的存储系统，一次查询所消耗的时间，都取决两个因素：
  1. 查找的时间复杂度
  2. 数据总量   
  
查找的时间复杂度有取决两个因素：
  1. 查找算法
  2. 存储数据的数据结构



**解决海量数据导致存储系统慢的问题，思想非常简单，就是一个`拆`字，把一大坨数据拆分成N个小坨，学名叫做“分片（Shard）”** ，拆开之后，每个分片里的数据就没有那么多了，然后查询尽可能的落到一个分片上，这样能提高查询性能。

##### 存档历史数据来提升查询性能

> 迁移归档之前一定要做好备份，这样如果误操作了，也能恢复数据  

##### 如何大批量删数据
 删除大批量数据的时候一定要分批删除，最好在每个删除操作之间停顿一会，避免给数据库造成太大压力。 最好根据索引来删除数据，并且排好序。因为MySQL的innoDB存储引擎中，表数据结构就是按照主键组织的一棵B+树。为什么要排好序呢？因为B+树的有序性，这些ID 相近的记录在磁盘物理文件上，大致也放一起，这样删除比较高效些，也便于MySQL回收页。
 
   
 大量delete 操作后观察MySQL占用的磁盘空间，发现并没有释放。
 
 #### 为什么删除数据后MySQL不释放磁盘空间？
   >  这个和innoDB的物理存储结构有关，虽然逻辑上个表是一棵B+树，但是物理上，每条记录都是存放在磁盘文件上的，这些记录通过以下位置指针来组织称一棵B+树，当MySQL删除一条数据时，只能找到记录所在的文件中位置，然后把这块区域标记为空闲，然后再修改B+树中相关的一些指针，完成删除，其实那条被删除的记录还是躺在那个文件的那个位置，所以不会释放磁盘空间。 
   
   >> 因为文件就是一段连续的二进制字节，类似于数组，所以它不支持从数组中删除一部分数据，如果非要删除，只能把这个位置之后的所有数据往前挪，这样等于移动大量数据，非常非常慢，所以删除的时候，只是记录一下，并不真正的删除，后续写入新数据的时候再重用那块地址。这会如果更新、插入数据就会造成数据页的分裂合并，会造成有部分空间无法有效的利用到，也会造成所谓的`数据空洞`。 如果要去掉这部分空洞，达到充分利用表空间的的目的，可以去 **recreate  table**
   
如果数据库的磁盘空间很紧张，**非要释放一部分空间，可以执行  OPTIMIZE TABLE （optimize table t 等于 recreate+analyze） 释放存储空间**。 对于innoDB 来说执行上述命令实际上就是把这个表重做了一遍，执行过程中会一直**锁表**，还有个前提条件MySQL必须配置每个表是一个独立的表空间（innodb_file_per_table = on）,**如果所有的表都放一起，那么执行  OPTIMIZE TABLE 也不会释放磁盘。**  

重建表后索引也会重建，会更加紧凑，有助于提升查询效率。

如果可以暂停服务，最快的做法是创建一个临时表，然后把当前表的数据复制到临时表中，把旧的表改名，然后再把临时表改成正式表明。

> innodb_file_per_table = ON  表示每个innodb表数据存放在一个 .idb 的文件里  
 innodb_file_per_table=off表示表数据都存放在系统共享表空间，也就是跟数据字典放在一起。  自5.6.6 开始就默认为ON

```
# 以订单表举例
# 创建一个临时订单表
create table orders_tmp like orders;

# 把订单表复制到临时表中
insert into orders_tmp (select * from orders where order_id > 9999999);

# 修改替换表名
rename table orders to orders_to_be_droppd, orders_tmp to  orders;

## 删除旧表
drop table  orders_to_be_dropp 
```




